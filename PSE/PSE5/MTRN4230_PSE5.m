%%%%%%%%%%%%%
% MTRN4230 PSE5 
% Investigate path planners
% Cameron MURRAY
% z3417671

function MTRN4230_PSE5
close all; clear variables; clc;
%dbstop if error

% Construct a 2-link simple planar manipulator, using section 7.2.1 of
% Corke. See 'Tutorial problem 1' in the lecture notes for Kinematics 3.
L(1) = Link([0 0 0.5 0]);
L(2) = Link([0 0 0.5 0]);
% Also create a model of the first link, for the purpose of collision
% checking
one_link = SerialLink(L(1), 'name', 'one link');
two_link = SerialLink(L, 'name', 'two link');
q_goal = [175, -5]/180*pi;
q_start = [5, 5]/180*pi;

% Define matrix over which configuration space will be sampled
n1 = 100;
min1 = -pi;
max1 = pi;
n2 = 100;
min2 = -150/180*pi;
max2 = 150/180*pi;
angles1 = min1:(max1 - min1)/(n1 - 1):max1;
angles2 = min2:(max2 - min2)/(n2 - 1):max2;
config_space_binary = zeros(n1, n2);

% Limits on range of motion in Cartesian plan
y_top = 0.6;
y_bottom = 0;


%% Generate discretised plot of joint space 
for i = angles1
    % Check position at end of first link
    [x1, y1, z1] = transl(one_link.fkine(i));
    for j = angles2
        % If position of first link invalid, flag it.
        if(y1 < y_bottom || y1 > y_top) 
            index_x = angle2cell(i, min1, max1, n1);
            index_y = angle2cell(j, min2, max2, n2);
            config_space_binary(index_x, index_y) = 1;
            continue;
        end
        % Check position of the end of the second link
        [x2, y2, z2] = transl(two_link.fkine([i, j]));
        if(y2 < y_bottom || y2 > y_top) % If invalid, flag it.
            index_x = angle2cell(i, min1, max1, n1);
            index_y = angle2cell(j, min2, max2, n2);
            config_space_binary(index_x, index_y) = 1;
        end
    end
end

%% Plot this with joint 1 on x axis and joint 2 on y axis
%   1.1. (1 point) Plot the obstacles above and below the robot arm
figure(1); 
imagesc(config_space_binary'); % Note the transpose of the joint space for convenience
axis xy; % Sets axis with x and y positive directions as expected, not as image coordinates
xlabel('Joint 1 [index in cell array], corresponding to 0 degrees in the middle')
ylabel('Joint 2 [index in cell array], corresponding to 0 degrees in the middle')

%% Calculate the start and goal cells (using the angle2cell function)
q_goal(1) = angle2cell(q_goal(1),min1, max1, n1);
q_goal(2) = angle2cell(q_goal(2),min2, max2, n2);
q_start(1) = angle2cell(q_start(1),min1, max1, n1);
q_start(2) = angle2cell(q_start(2),min2, max2, n2);

%% DStar planner
%   1.2. (2 points) Generate the shortest path using D* and plot it in the 
%   discrete joint space overlaid on the cost map. See section 5.2.2. of 
%   the Corke textbook.
%   Set up the cost map for DStar
%   Plot the costmap and the path in joint space
figure(2);
ds = Dstar(config_space_binary');
ds.plan(q_goal)
ds.path(q_start)
Dspath = ds.path(q_start);

%   1.3. (1 point) Convert this path back to joint angles and animate the 
%   robot to follow the path
figure(3);
DsangularPath = path2angles(Dspath, min1, max1, min2, max2, n1, n2);
alpha(patch([1, -1, -1, 1], [0, 0, 0, 0], [1, 1, -1, -1], [0, 1, 0]), 0.5);
alpha(patch([1, -1, -1, 1], [0.6, 0.6, 0.6, 0.6], [1, 1, -1, -1], [0, 1, 0]), 0.5);
two_link.plot(DsangularPath', 'view', 'top');

%% Probabilistic Roadmap Planner
%   1.4. (2 points) Generate a path using PRM and plot it in the discrete joint space overlaid on the road
%   map. See section 5.2.4. of the Corke textbook.
figure(4); hold on;
prm = PRM(config_space_binary', 'npoints', n1/2);
%   Plot the PRM in joint space
prm.plan();
prm.plot();
Prmpath = prm.path(q_start, q_goal);
plot(Prmpath(:,1), Prmpath(:,2), 'g.');

%   1.5. (1 point) Convert this path back to joint angles and animate the 
%   robot to follow the path
%   Calculate the path
%   Animate the path taken by the two_link robot generated by PRM
figure(3);
PrmangularPath = path2angles(Prmpath, min1, max1, min2, max2, n1, n2);
alpha(patch([1, -1, -1, 1], [0, 0, 0, 0], [1, 1, -1, -1], [0, 1, 0]), 0.5);
alpha(patch([1, -1, -1, 1], [0.6, 0.6, 0.6, 0.6], [1, 1, -1, -1], [0, 1, 0]), 0.5);
two_link.plot(PrmangularPath', 'view', 'top');

end

% function i = angle2cell(angle, min, max, n)
% Converts an angle into a cell value, given the minimum, maximum angles
% and number of cells.
function i = angle2cell(angle, min, max, n)
    if(angle < min || angle > max), error('angle2cell: angle out of range'); end
    i = round((angle - min) / (max - min) * (n - 1) + 1);  
end

% function angle = cell2angle(i, min, max, n)
% Converts a cell value into an angle, given the minimum, maximum angles
% and number of cells.
function angle = cell2angle(i, min, max, n)
    if(i < 1 || i > n), error('cell2angle: cell out of range'); end
    angle = (i - 1) / (n- 1) * (max - min) + min;
end

function angles = path2angles(path, min1, max1, min2, max2, n1, n2)
    pLen = length(path);
    angles = zeros(2, pLen);
    for i=1:pLen
        angles(1,i) = cell2angle(path(i,1), min1, max1, n1);
        angles(2,i) = cell2angle(path(i,2), min2, max2, n2);
    end
end

%   1.6. (3 points) Describe and discuss the difference between the paths generated in terms of the
%   algorithms used.
%   D* - Grid Based Algorithm: Grid overlayed on configuration space. Each
%   configuration corresponds with a cell. Each cell has the value of the
%   shortest distance to the goal. Gradient descent gives path to goal. A
%   traversal cost is defined for each cell. It searches to minimise cost
%   but have arbitrarily sharp corners on the path (inconvenient for high
%   speed motion.

%   PRM - Probabilistic Road Map; Sampling Based Algorithm: Sampling based
%   algorithms represent te configuration space with a roadmap of sampled
%   configurations. A basic algorithm samples N RANDOM configurations in C
%   and retains those in C_free to use as nodes. Collision detection is    
%   used to test inclusion of the path between two nodes to be in C_free. 
%   There is a node at both Start and Goal. The performance of a
%   probabilistically complete planner is measured by the rate of
%   convergence.
%   Step 1) Construction: contruct a random configuration 
%   Step 2) Query: does the random configuration in C_free? If so, then
%   return that path

















